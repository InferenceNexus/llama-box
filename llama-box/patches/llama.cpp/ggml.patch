diff --git a/ggml/include/ggml-metal.h b/ggml/include/ggml-metal.h
index 669c1f84..a2ad685d 100644
--- a/ggml/include/ggml-metal.h
+++ b/ggml/include/ggml-metal.h
@@ -61,6 +61,8 @@ GGML_BACKEND_API void ggml_backend_metal_capture_next_compute(ggml_backend_t bac
 
 GGML_BACKEND_API ggml_backend_reg_t ggml_backend_metal_reg(void);
 
+GGML_API void ggml_backend_metal_get_device_memory(ggml_backend_t backend, size_t * free_mem, size_t * total_mem);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/ggml/src/ggml-metal/ggml-metal.m b/ggml/src/ggml-metal/ggml-metal.m
index d1abb3ce..38cf6f10 100644
--- a/ggml/src/ggml-metal/ggml-metal.m
+++ b/ggml/src/ggml-metal/ggml-metal.m
@@ -1929,13 +1929,12 @@ static void ggml_metal_encode_node(
                 // to the matrix-vector kernel
                 int ne11_mm_min = 1;
 
-#if 0
                 // the numbers below are measured on M2 Ultra for 7B and 13B models
                 // these numbers do not translate to other devices or model sizes
                 // TODO: need to find a better approach
-                        if ([device.name isEqualToString:@"Apple M2 Ultra"]) {
+                        {
                             switch (src0t) {
-                                case GGML_TYPE_F16:  ne11_mm_min = 2;  break;
+                                case GGML_TYPE_F16:  ne11_mm_min = 4;  break;
                                 case GGML_TYPE_Q8_0: ne11_mm_min = 7;  break;
                                 case GGML_TYPE_Q2_K: ne11_mm_min = 15; break;
                                 case GGML_TYPE_Q3_K: ne11_mm_min = 7;  break;
@@ -1946,10 +1945,9 @@ static void ggml_metal_encode_node(
                                 case GGML_TYPE_Q5_1: ne11_mm_min = 13; break; // not tested yet
                                 case GGML_TYPE_Q5_K: ne11_mm_min = 7;  break;
                                 case GGML_TYPE_Q6_K: ne11_mm_min = 7;  break;
-                                default:             ne11_mm_min = 1;  break;
+                                default:             ne11_mm_min = 4;  break;
                             }
                         }
-#endif
 
                         // for now the matrix-matrix multiplication kernel only works on A14+/M1+ SoCs
                         // AMD GPU and older A-chips will reuse matrix-vector multiplication kernel
@@ -2672,7 +2670,6 @@ static void ggml_metal_encode_node(
             } break;
         case GGML_OP_GROUP_NORM:
             {
-                GGML_ASSERT(ne00 % 4 == 0);
                 GGML_ASSERT(ggml_is_contiguous(src0));
 
                 float eps;
@@ -4184,6 +4181,10 @@ static void ggml_backend_metal_device_get_memory(ggml_backend_dev_t dev, size_t
     }
 }
 
+void ggml_backend_metal_get_device_memory(ggml_backend_t backend, size_t *free, size_t *total) {
+    ggml_backend_metal_device_get_memory(backend->device, free, total);
+}
+
 static enum ggml_backend_dev_type ggml_backend_metal_device_get_type(ggml_backend_dev_t dev) {
     return GGML_BACKEND_DEVICE_TYPE_GPU;
 
